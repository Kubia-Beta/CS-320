# CS-320 : Connor Sculthorpe
This contains the code for a mobile app that is requested by a mock customer.

These files are meant to demonstrate the importance of full test coverage, and the deliberate avoidance of magic numbers in published code, along with clear and concise comments in readable code. It is designed to be high quality, as to keep its maintainability high.

The final version of the project is located [here](3-2%20Contact%20Service/src) in the .src path for Main and Test. In Main resides the functioning code, in Test resides the respective tests to demonstrate both code coverage as well as functionality.

## How can I ensure that my code, program, or software is functional and secure?
Ensuring that software is functional and secure is no small feat and has many moving parts in its success. Code requires its requisite tests, from white box tests which verify coverage to black box tests which verify functionality. Security is itself a problem to be considered in the early phases of design, and requires the designers to use caution, to be deliberate and considerate with their choices. By following existing secure design patterns, parts of development that otherwise become exposed later can be secured early, guaranteeing a lower overhead to the programâ€™s development.
## How do I interpret user needs and incorporate them into a program?
I can ensure that user needs are incorporated by actively incorporating user feedback. From user testing to surveying to user stories, users can provide insights into what does and does not work for the user within the program. The first and largest step exists in the requirements gathering phase, where we can ensure user needs are included and prioritized from the outset of the program.
## How do I approach designing software?
My process for designing software starts with conceptualization, or the core problems that the software could address, and follows the V Model (Hambling et al., 2019). Naturally, that means we will progress through requirement specification, functional specification, technical specification, to program specification, finally to begin coding, all the while planning our testing phase. What comes after is then unit testing, integration testing, system testing, and ends with acceptance testing. This means that I do not like designing code first, and I only wish to proceed when the documentation has already been produced, analyzed, and tested, at which point you naturally begin designing the program in UML and planning unit tests to then move onto creating the program in code.

<p align="center"><Code>References</Code></p>
Morgan, P., Samaroo, A., Thompson, G., & Williams, P. (2019). Software testing: An ISTQB-BCS Certified Tester Foundation Guide (B. Hambling, Ed.; 4th ed.). BCS Learning and Development Ltd.

